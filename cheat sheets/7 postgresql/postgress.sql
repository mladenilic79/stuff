
/*
after installation of postgresql to execute psql from terminal add postgresql path to system variable if needed
*/

/*
connect to server & database using psql
open psql and get prompt
    Server [localhost]:
paste url for connection to server or except localhost with enter
    Database [postgres]:
input database name you want to connect to or just accept default postgres database with enter
    Port [5432]:
input port to use of accept default port with enter
    Username [postgres]:
en enter we will be prompted for password, input user password and enter
*/

-- quit psql
\q

-- list all databases
\list
\l

-- connect to database
\connect mydb1
\c mydb1

-- describe
\d -- database
\dt -- database tables only
\d person -- specific object

-- run sql from file, set file permissions before this
\i C:\Users\Administrator.DRHW10EDGE10\Desktop\postgres\person.sql

-- toggle standard & expended output
\x

/*
to control execution of postgresql use commands:
BEGIN or BEGIN TRANSACTION;
COMMIT or COMMIT TRANSACTION;
SAVEPOINT my_savepoint;
ROLLBACK or ROLLBACK TRANSACTION;
ROLLBACK TO my_savepoint;
*/

-- create database
CREATE DATABASE testingDatabase;

-- delete database
DROP DATABASE testingDatabase;

/*
types
SERIAL / BIGSERIAL - for ids
INTEGER / BIGINT - bigint is bigger, used for integers
NUMERIC / DECIMAL - they are the same, they have high precision
REAL / DOUBLE PRECISION - double is bigger, both not very precise
CHAR - string of specified length, default length is 1, missing characters are filled with whitespace
VARCHAR - string of specified length, default length is max, missing characters are not filled with whitespace
TEXT - same as varchar without an argument
DATE / TIME / TIMESTAMP - timestamp is date & time together
INTERVAL - used with date/time/timestamp
BOOLEAN - ...
*/

-- create table
CREATE TABLE car(
    car_id SERIAL PRIMARY KEY,
    make VARCHAR NOT NULL,
    model VARCHAR(100) NOT NULL,
    price NUMERIC(19,2) NOT NULL
);
CREATE TABLE person(
-- CREATE TEMPORARY TABLE person( - table remove by the end of database session or transaction
    id BIGSERIAL PRIMARY KEY,
    -- primary key per sql standard, so no serial
    -- id INT GENERATED ALWAYS AS IDENTITY, - generate always
    -- id INT GENERATED BY DEFAULT AS IDENTITY, - generate if not provided on insert
    first_name VARCHAR(50) NOT NULL DEFAULT 'Sara', -- put default if value not provided
    last_name VARCHAR(50) NOT NULL,
    gender VARCHAR(15) NOT NULL CHECK(gender = 'Female' OR gender = 'Male' OR gender = 'Agender' OR gender = 'Non-binary' OR gender = 'Genderqueer'),
    email VARCHAR(150),
    date_of_birth DATE NOT NULL,
    country_of_birth VARCHAR(50),
    randomnumber DECIMAL(19,2) UNIQUE,
    -- constraint can be written also like this
    -- randomnumber DECIMAL(19,2),
    -- UNIQUE(price)
    
    car_id BIGINT REFERENCES car (car_id),
    -- car_id BIGINT REFERENCES car (car_id) ON DELETE CASCADE - add cascade or other options like this:
    -- ON DELETE SET NULL, ON DELETE RESTRICT, ON DELETE NO ACTION, ON DELETE SET DEFAULT
    
    -- this is self join
    -- foreign key can also be written like this
    manager_id INT,
	FOREIGN KEY (manager_id) REFERENCES person (id) 
);

-- delete table
DROP TABLE person;
DROP TABLE IF EXISTS person;

-- indexes
CREATE INDEX person_index_1 ON person(first_name);
CREATE INDEX person_index_2 ON person(first_name, last_name);
DROP INDEX IF EXISTS person_index_1;
DROP INDEX person_index_2;

-- modify constraints drop
ALTER TABLE person DROP CONSTRAINT person_pkey; -- primary key in this case
ALTER TABLE person DROP CONSTRAINT person_car_id_fkey; -- foreign key in this case
ALTER TABLE person DROP CONSTRAINT person_gender_check;
ALTER TABLE person DROP CONSTRAINT person_randomnumber_key;
-- modiry constraints add
ALTER TABLE person ADD PRIMARY KEY (id); -- add primary key - will work if there are no duplicates
ALTER TABLE person ADD FOREIGN KEY (car_id) REFERENCES car (car_id);
-- modify constraints add alternatively with letting database set the name for them
ALTER TABLE person ADD UNIQUE(email); -- will work if there are no duplicates
ALTER TABLE person ADD CHECK(gender = 'Female' OR gender = 'female' OR gender = 'Male' OR gender = 'male' OR gender = 'Agender' OR gender = 'Non-binary' OR gender = 'Genderqueer' OR gender='Genderfluid'); -- add checked constraint let db choose name for you
-- modify constraints add (with setting custom name)
ALTER TABLE person ADD CONSTRAINT unique_email UNIQUE(email); -- will work if there are no duplicates
ALTER TABLE person ADD CONSTRAINT gender_check CHECK(gender = 'Female' OR gender = 'female' OR gender = 'Male' OR gender = 'male' OR gender = 'Agender' OR gender = 'Non-binary' OR gender = 'Genderqueer' OR gender='Genderfluid'); -- add checked constraint with choose name

-- alter table
ALTER TABLE person ADD COLUMN another_column VARCHAR;
ALTER TABLE person ALTER COLUMN another_column SET NOT NULL; -- this will work after populating the column
ALTER TABLE person ALTER COLUMN another_column SET DEFAULT 'Pera'; -- this will work after populating the column
ALTER TABLE person ADD UNIQUE (another_column); -- this will work if all values are unique
ALTER TABLE person RENAME COLUMN another_column TO another_column_2;
ALTER TABLE person DROP COLUMN another_column_2;
ALTER TABLE person RENAME TO person2;
ALTER TABLE person2 RENAME TO person;

-- restart sequence / auto numbering
ALTER SEQUENCE person_id_seq RESTART WITH 1000;

-- insert into table

INSERT INTO person(first_name, last_name, gender, email, date_of_birth, country_of_birth, randomnumber) 
VALUES('Anne', 'Smith', 'Female', 'jake@gmail.com', DATE '1993-01-03', 'US', 444);  -- convert string to date with DATE function

INSERT INTO person(first_name, last_name, gender, email, date_of_birth, country_of_birth, randomnumber) 
VALUES('Bri', 'Smith', 'Female', 'bri@gmail.com', DATE '1989-01-03', NULL, 5.5);

INSERT INTO person(first_name, last_name, gender, email, date_of_birth, country_of_birth, randomnumber)
VALUES('Jack', 'Smith', 'Male', 'jake@gmail.com', DATE '1993-02-03', 'Paris', 888)
ON CONFLICT (email) DO NOTHING; -- this will work on unique column, and will prevent an error

INSERT INTO person(
    first_name, last_name, gender, email, date_of_birth, country_of_birth, randomnumber
) VALUES(
    'Marica', 'Smith', 'Male', 'jake@gmail.com', DATE '1993-02-03', 'London', 333
) ON CONFLICT (email) DO UPDATE SET email = EXCLUDED.email, first_name = EXCLUDED.first_name; -- this will work on unique column, and will prevent an error and update the field instead of doing nothing

INSERT INTO person(first_name, last_name, gender, email, date_of_birth, country_of_birth, randomnumber)
VALUES
    ('Anne', 'Smith', 'Female', 'Kjake@gmail.com', DATE '1993-01-03', 'US', 444),
    ('Bri', 'Smith', 'Female', 'Lbri@gmail.com', DATE '1989-01-03', NULL, 5.5),
    ('Jack', 'Smith', 'Male', 'djake@gmail.com', DATE '1993-02-03', 'Paris', 888),
    ('Marica', 'Smith', 'Male', 'JHjake@gmail.com', DATE '1993-02-03', 'London', 333);

-- update whole table -- !!!!!!!!! this will update whole table don't do this !!!!!!!!!!
UPDATE person SET email = 'omar@gmail.com'; -- !!!!!!!!! this will update whole table don't do this !!!!!!!!!!

-- update records
UPDATE person SET email = 'omar@gmail.com' WHERE id = 1;
UPDATE person SET gender = 'Male', country_of_birth = 'Paris' WHERE id = 2;

-- delete all inside table -- !!!!!!!!! this will empty table don't do this !!!!!!!!!!
DELETE FROM person; -- !!!!!!!!!! this will empty table don't do this !!!!!!!!!!
TRUNCATE TABLE person; -- !!!!!!!!!! this will empty table don't do this !!!!!!!!!!
TRUNCATE TABLE person RESTART IDENTITY; -- !!!!!!!!!! also restart ids to start from 1 !!!!!!!!!!

-- delete records
DELETE FROM person WHERE id = 1;
DELETE FROM person WHERE gender = 'Male' AND country_of_birth = 'Paris';

-- input big files here

-- select / from
SELECT * FROM person;
SELECT *, first_name FROM person;
SELECT first_name, last_name FROM person;

-- some keywords
SELECT DISTINCT country_of_birth FROM person ORDER BY country_of_birth; -- distinct(unique values/rows only)
SELECT * FROM person LIMIT 10; -- limit/fetch(return only number of records)
SELECT * FROM person FETCH FIRST 10 ROWS ONLY; -- fetch is same as limit just is part of sql standard
SELECT * FROM person OFFSET 10; -- offset(return records after that number of records), skip first 10, 
SELECT country_of_birth AS country FROM person; -- as(alias)

-- some functions
SELECT first_name, coalesce(email, 'default value if value missing') FROM person; -- returns first NOT NULL argument
-- handle null value - nullif returns 1st argument if both values are not equel, returns null if they are equal
SELECT first_name, 10/NULLIF(randomnumber, 0) AS new_price FROM person; -- this will replace 0 with null to prevent division with zero
SELECT first_name, UPPER(first_name) AS upper_first_name, LOWER(first_name) AS lower_first_name FROM person;
SELECT first_name, LENGTH(first_name) AS length_of_first_name FROM person;
SELECT first_name, TRIM(first_name) AS trimmed_first_name FROM person;
SELECT CONCAT(first_name, ' ', last_name) AS full_name, country_of_birth FROM person;
SELECT first_name || ' ' || last_name AS full_name FROM person; -- also concat
SELECT first_name, GREATEST(randomnumber, 50), LEAST(randomnumber, 20) FROM person;
SELECT '100'::INTEGER;

-- case
SELECT
    first_name,
    randomnumber,
    CASE
        WHEN randomnumber > 50 THEN 'number high'
        WHEN randomnumber > 30 THEN 'number low'
        ELSE 'very bad' -- else is not mandatory, but will then return NULL
    END
FROM person;

-- +(add) / -(subtract) / *(multiply) / /(division) / ^(power) / %(moduo)
SELECT randomnumber, randomnumber * 2 AS MULT, randomnumber / 2 AS DIV, randomnumber + randomnumber AS ADS, randomnumber - randomnumber AS SUB, randomnumber ^ 2 AS POWER, randomnumber % 3 AS MODUL FROM person;

-- dates - refer to the official documentation
SELECT NOW(); -- return this moment
SELECT NOW()::DATE; -- casting to only date
SELECT NOW()::TIME; -- casting to only time
SELECT NOW()::TIMESTAMP; -- casting to only time
-- interval used for conversion
SELECT NOW() - INTERVAL '1 YEAR';
SELECT NOW()::DATE + INTERVAL '5 MONTHS'; -- casting here will round date but now change pattern
SELECT (NOW() + INTERVAL '10 DAYS')::DATE; -- cast it in the end
-- extract used for specific element of the date/time
SELECT EXTRACT(YEAR FROM NOW());
SELECT EXTRACT(MONTH FROM NOW());
SELECT EXTRACT(DAY FROM NOW());
SELECT EXTRACT(DOW FROM NOW()); -- DOW - day of the week
SELECT first_name, EXTRACT(MONTH FROM date_of_birth) AS month_of_birth FROM PERSON;
SELECT first_name, AGE(NOW(), date_of_birth) AS age FROM person; -- AGE returns time between two dates

-- where / and / or / in / between / like / ilike / < > <= >= <> !=
SELECT * FROM person WHERE date_of_birth >= DATE '1990-06-01';
SELECT * FROM person WHERE date_of_birth > DATE '1990-06-01';
SELECT * FROM person WHERE gender = 'Non-binary' OR  country_of_birth = 'China';
SELECT * FROM person WHERE gender != 'Female' AND gender <> 'Male';
SELECT * FROM person WHERE country_of_birth IN ('Russia', 'France');
SELECT * FROM person WHERE country_of_birth NOT IN ('Russia', 'China', 'Argentina', 'Indonesia', 'Brazil', 'Portugal', 'France');
SELECT * FROM person WHERE date_of_birth BETWEEN DATE '2000-01-01' AND '2023-01-01';
SELECT * FROM person WHERE email LIKE '%o.com'; -- % means any number of characters
SELECT * FROM person WHERE email LIKE '%oo%';
SELECT * FROM person WHERE email LIKE '_________@_________.com'; -- _ represents single character
SELECT * FROM person WHERE country_of_birth ILIKE 'p%'; -- ILIKE same as LIKE just ignores case
SELECT * FROM person WHERE email SIMILAR TO '%oo%'; -- SIMILAR TO - stronger then LIKE - interprets regex differently
SELECT * FROM person WHERE email ~ '.+@ovh.net'; -- ~ more powerfull then SIMILAR TO - interprets regex differently
SELECT * FROM person WHERE email = NULL;
SELECT * FROM person WHERE email IS NULL;
SELECT * FROM person WHERE email IS NOT NULL;

-- aggragate / group by / having (having is filtering of groups)

-- count
SELECT COUNT(*) FROM PERSON;
SELECT country_of_birth, COUNT(*) FROM person GROUP BY country_of_birth;
SELECT country_of_birth, COUNT(*) FROM person GROUP BY country_of_birth HAVING COUNT(*) > 2;

-- min / max / avg / sum / round
SELECT MAX(randomnumber) FROM person;
SELECT MIN(randomnumber) FROM person;
SELECT ROUND(AVG(randomnumber)) FROM person;
SELECT SUM(randomnumber) FROM person;
SELECT country_of_birth, MIN(randomnumber) FROM person GROUP BY country_of_birth;
SELECT country_of_birth, SUM(randomnumber) FROM person GROUP BY country_of_birth HAVING SUM(randomnumber) <= 50;
SELECT first_name, country_of_birth, MIN(randomnumber) FROM person GROUP BY first_name, country_of_birth; -- double grouping

--order by / asc/desc
SELECT * FROM person ORDER BY last_name; -- asscending is default
SELECT * FROM person ORDER BY last_name ASC;
SELECT * FROM person ORDER BY last_name DESC;
SELECT * FROM person ORDER BY first_name, last_name; -- combine order

-- joins

-- inner
SELECT * 
FROM person
    JOIN car ON person.car_id = car.car_id;
    -- JOIN table_y ON table_x.id = table_y.id; -- add like this in case of joining more tables
    -- JOIN expression can have AND expression inside for more advanced joining

-- inner join same as join
SELECT *, person.first_name
FROM person
    INNER JOIN car ON person.car_id = car.car_id;

-- if both ids are the same keyword USING can be used
SELECT *
FROM person
    JOIN car USING(car_id);

-- natural join, joining is done intuitively by db engine, discarding duplicate columns
SELECT * 
FROM person
    NATURAL JOIN car;

-- left (take all from left)
SELECT *
FROM person
    LEFT JOIN car ON person.car_id = car.car_id;

-- right (take all from right)
SELECT *
FROM person
    RIGHT JOIN car ON person.car_id = car.car_id;

-- full outer join (is combination of left join & right join)
SELECT *
FROM person
    FULL JOIN car ON person.car_id = car.car_id;

-- cross join (include each row from both tables)
SELECT *
FROM person
    CROSS JOIN car;

-- self join - for organizational or hierarchical structure
SELECT
    CONCAT(m.first_name, ' ', m.last_name) AS employee_full_name,
    CONCAT(e.first_name, ' ', e.last_name) AS manager_full_name
FROM
    employee e
    INNER JOIN employee m ON m.employee_id = e.manager_id
-- or to include top name use LEFT insted of INNER JOIN
SELECT
    CONCAT(m.first_name, ' ', m.last_name) AS manager_full_name,
    CONCAT(e.first_name, ' ', e.last_name) AS employee_full_name
FROM
    employee e
    INNER JOIN employee m ON m.employee_id = e.manager_id

-- union for stacking data verticaly (data must be stackable for this to work)

-- union (remove all duplicates)
SELECT id, first_name, last_name, randomnumber FROM person
UNION
SELECT * FROM car
UNION
SELECT * FROM car;

-- union all (keep all duplicates)
SELECT id, first_name, last_name, randomnumber FROM person 
UNION ALL
SELECT id, first_name, last_name, randomnumber FROM person ORDER BY first_name;

-- INTERSECT - find rows that are the same and remove duplicates
-- INTERSECT ALL - find rows that are the same and keep the duplicates
-- EXCEPT - find rows present in first query only and remove duplicates
-- EXCEPT ALL - find rows present in first query only and keep the duplicates

-- subqueries

-- subquery in from
SELECT a.first_name, a.last_name FROM (SELECT * FROM person) a; -- a refers to the subquery

-- subquery in where
SELECT * FROM person WHERE country_of_birth IN (SELECT country_of_birth FROM person);

-- all - true for all values returned by subquery
SELECT * FROM person WHERE randomnumber > ALL (SELECT randomnumber FROM person WHERE country_of_birth = 'China');

-- exists - returns true is subquery returns anything
SELECT * FROM person WHERE EXISTS (SELECT randomnumber FROM person WHERE country_of_birth = 'China');

-- some / any - true for at least one element returned by subquery?
-- another subquery example here

-- views - basicly tables also

-- view will be updateble if there is only one entry in FROM clause and there is no
-- GROUP BY, HAVING, LIMIT, OFFSET, DISTINCT, UNION, INTERSECT, and EXCEPT, and no aggregate functions
CREATE VIEW custom_view AS
-- CREATE OR REPLACE VIEW custome_view AS
SELECT * FROM person;
-- call view with
SELECT * FROM custom_view;
-- delete view with
DROP VIEW custom_view;

-- materialized views
-- .................................................
-- views WITH CHECK OPTION
-- .................................................
-- recursive views
-- .................................................

-- table copies

-- making copies of tables also with temporary keyword
SELECT * 
INTO TEMPORARY TABLE new_table 
-- INTO TEMP TABLE new_table 
-- INTO TABLE new_table 
FROM person;

-- CREATE [TEMP] [IF NOT EXISTS] TABLE new_table_name AS query
CREATE TABLE new_table AS
SELECT * FROM person;















-- sql function

CREATE OR REPLACE FUNCTION function_example_1(random_text text)
CREATE OR REPLACE FUNCTION function_example_1(random_text text)
RETURNS person
AS
$$
 SELECT * FROM person WHERE last_name = random_text;
$$
LANGUAGE SQL;
SELECT function_example_1('Jozwik');
SELECT function_example_1(random_text => 'Jozwik');
SELECT (function_example_1('Jozwik')).*;
SELECT (function_example_1('Jozwik')).first_name;















-- plpgsql

-- CREATE OR REPLACE FUNCTION function_example()
CREATE OR REPLACE FUNCTION plpgsql_function_example_1(variable_1_in INT)
-- RETURNS VOID
-- RETURNS VARCHAR
RETURNS INT
LANGUAGE PLPGSQL
AS
    $$
    DECLARE
            temp_value INT;
            value_4_out INT;
    BEGIN
        SELECT COUNT(*)
        FROM person
        INTO temp_value;

        value_4_out := variable_1_in + temp_value;
        -- or like this:
        -- SELECT variable_1_in + temp_value INTO value_4_out;

        RETURN value_4_out;
    END;
    $$;
SELECT plpgsql_function_example_1(3); -- one field format
SELECT plpgsql_function_example_1(variable_1_in => 3);

CREATE OR REPLACE FUNCTION plpgsql_function_example_2(IN variable_1 INT, IN variable_2 INT, OUT variable_3 INT, OUT variable_4 INT, INOUT variable_5 INT)
LANGUAGE PLPGSQL
AS
    $$
    DECLARE
        temp_value_1 INT;
        temp_value_2 INT;
    BEGIN
        SELECT COUNT(*)
        FROM person
        INTO temp_value_1;

        SELECT MAX(randomnumber)
        FROM person
        INTO temp_value_2;

        SELECT variable_1 + temp_value_1 INTO variable_3;
        variable_4 := variable_2 + temp_value_2;
    END;
    $$;
SELECT plpgsql_function_example_2(3, 4, 5); -- field format
SELECT (plpgsql_function_example_2(3, 4, 5)).*; -- table format
SELECT (plpgsql_function_example_2(3, 4, 5)).variable_3 -- get specific field

-- and more completex plpgsql...
